/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body - Clean USB Host CDC
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "lcd.h"
#include "usb_host.h"
#include "usbh_cdc.h"
#include "usbh_core.h"
#include <stdint.h>
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */

/* Private variables ---------------------------------------------------------*/
SPI_HandleTypeDef hspi2;

/* USER CODE BEGIN PV */
// DMA传输状态标志 - LCD需要
volatile uint8_t dma_transfer_complete = 1;

// CDC数据缓冲区
uint8_t CDC_RX_Buffer[512];

// USB Host相关变量
extern USBH_HandleTypeDef hUsbHostFS;
extern ApplicationTypeDef Appli_state;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MPU_Config(void);
static void MX_GPIO_Init(void);
void MX_USB_HOST_Init(void);
void MX_USB_HOST_Process(void);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void) {
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MPU Configuration--------------------------------------------------------*/
  MPU_Config();

  /* MCU Configuration--------------------------------------------------------*/
  HAL_Init();

  /* USER CODE BEGIN Init */
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */
  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_SPI2_Init();
  MX_USB_HOST_Init();

  /* USER CODE BEGIN 2 */
  // Initialize LCD
  HAL_GPIO_WritePin(LCD_BLK_PORT, LCD_BLK_PIN, GPIO_PIN_SET);
  HAL_Delay(100);

  LCD_Reset();
  LCD_Init();
  LCD_Clear(DARK_BLUE);

  // 显示标题
  LCD_DrawString(0, 10, "USB Host CDC Test", WHITE, DARK_BLUE);
  
  // LED指示启动完成
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_SET);
  HAL_Delay(200);
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1) {
    /* USER CODE END WHILE */
    
    // 获取当前时间
    uint32_t current_time = HAL_GetTick();
    
    // 时间显示 - 每100ms更新
    static uint32_t last_time_update = 0;
    if (current_time - last_time_update >= 100) {
      last_time_update = current_time;
      char time_str[30];
      sprintf(time_str, "Time: %lu.%lu s", current_time / 1000, (current_time % 1000) / 100);
      LCD_DrawString(0, 30, time_str, GREEN, DARK_BLUE);
    }
    
    // USB Host处理
    MX_USB_HOST_Process();
    
    /* USER CODE BEGIN 3 */
    
    // 状态显示 - 每200ms更新
    static uint32_t last_status_update = 0;
    if (current_time - last_status_update >= 200) {
      last_status_update = current_time;
      
      // 应用状态
      char app_str[40];
      sprintf(app_str, "App: %d", Appli_state);
      LCD_DrawString(0, 50, app_str, CYAN, DARK_BLUE);
      
      // USB Host状态
      char host_str[40];
      sprintf(host_str, "Host: %d Enum: %d", hUsbHostFS.gState, hUsbHostFS.EnumState);
      LCD_DrawString(0, 70, host_str, CYAN, DARK_BLUE);
      
      // 连接状态
      char conn_str[40];
      sprintf(conn_str, "Conn: %d Port: %d", 
              hUsbHostFS.device.is_connected, 
              hUsbHostFS.device.PortEnabled);
      LCD_DrawString(0, 90, conn_str, WHITE, DARK_BLUE);
      
      // 设备信息
      if (hUsbHostFS.device.DevDesc.idVendor != 0) {
        char dev_str[40];
        sprintf(dev_str, "VID:PID %04X:%04X", 
                hUsbHostFS.device.DevDesc.idVendor,
                hUsbHostFS.device.DevDesc.idProduct);
        LCD_DrawString(0, 110, dev_str, YELLOW, DARK_BLUE);
      } else {
        LCD_DrawString(0, 110, "No Device Info", YELLOW, DARK_BLUE);
      }
      
      // CDC状态
      if (Appli_state == APPLICATION_READY) {
        LCD_DrawString(0, 130, "CDC: Ready", GREEN, DARK_BLUE);
        
        // 尝试接收数据
        USBH_CDC_Receive(&hUsbHostFS, CDC_RX_Buffer, 64);
        uint32_t rx_len = USBH_CDC_GetLastReceivedDataSize(&hUsbHostFS);
        
        if (rx_len > 0) {
          char data_str[40];
          sprintf(data_str, "RX: %lu bytes", rx_len);
          LCD_DrawString(0, 150, data_str, GREEN, DARK_BLUE);
        } else {
          LCD_DrawString(0, 150, "RX: Waiting...", WHITE, DARK_BLUE);
        }
      } else {
        LCD_DrawString(0, 130, "CDC: Not Ready", RED, DARK_BLUE);
        LCD_DrawString(0, 150, "", DARK_BLUE, DARK_BLUE); // 清空数据行
      }
    }
    
    // LED心跳 - 每500ms闪烁
    static uint32_t last_led_toggle = 0;
    if (current_time - last_led_toggle >= 500) {
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1);
      last_led_toggle = current_time;
    }
    
    // 短暂延迟，避免CPU占用过高
    HAL_Delay(10);
  }
  /* USER CODE END 3 */
}

// 系统配置函数
void SystemClock_Config(void) {
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);

  while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {
  }

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOMEDIUM;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
                                RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |
                                RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) {
    Error_Handler();
  }
}

void MX_SPI2_Init(void) {
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 0x0;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  hspi2.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi2.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi2.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi2.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi2.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi2.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
  hspi2.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK) {
    Error_Handler();
  }
}

static void MX_GPIO_Init(void) {
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_12, GPIO_PIN_RESET);

  GPIO_InitStruct.Pin = GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  HAL_SYSCFG_AnalogSwitchConfig(SYSCFG_SWITCH_PA1, SYSCFG_SWITCH_PA1_CLOSE);
}

void MPU_Config(void) {
  MPU_Region_InitTypeDef MPU_InitStruct = {0};

  HAL_MPU_Disable();

  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress = 0x0;
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}

void Error_Handler(void) {
  __disable_irq();
  while (1) {
  }
}

// CDC接收回调函数
void USBH_CDC_ReceiveCallback(USBH_HandleTypeDef *phost) {
  uint32_t rx_len = USBH_CDC_GetLastReceivedDataSize(phost);
  if (rx_len > 0) {
    // 立即启动下一次接收
    USBH_CDC_Receive(phost, CDC_RX_Buffer, sizeof(CDC_RX_Buffer));
  }
}