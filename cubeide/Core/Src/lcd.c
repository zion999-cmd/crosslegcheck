/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : lcd.c
 * @brief          : LCD driver implementation
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "lcd.h"
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

// LCD Driver Functions
void LCD_Reset(void) {
  HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_SET);
  HAL_Delay(120);
}

// Ultra-fast software SPI - optimized to the extreme
static inline void SPI_WriteByte_Fast(uint8_t data) {
  // Pre-calculate all values for maximum speed
  uint32_t sck_set = LCD_SCK_PIN;
  uint32_t sck_reset = (uint32_t)LCD_SCK_PIN << 16U;
  uint32_t mosi_set = LCD_MOSI_PIN;
  uint32_t mosi_reset = (uint32_t)LCD_MOSI_PIN << 16U;

  // Unroll the loop for maximum speed - bit 7
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x80) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 6
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x40) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 5
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x20) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 4
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x10) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 3
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x08) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 2
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x04) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 1
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x02) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // bit 0
  GPIOB->BSRR = sck_reset;
  GPIOB->BSRR = (data & 0x01) ? mosi_set : mosi_reset;
  GPIOB->BSRR = sck_set;

  // Final clock low
  GPIOB->BSRR = sck_reset;
}

void LCD_WriteCommand(uint8_t cmd) {
  HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET); // Command mode
  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET); // Select LCD

  // 直接发送字节数据，不用指针
  uint8_t tx_data = cmd;
  while (HAL_SPI_GetState(&hspi2) != HAL_SPI_STATE_READY)
    ;
  HAL_SPI_Transmit(&hspi2, &tx_data, 1, 1000); // 减少超时时间

  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET); // Deselect LCD
}

void LCD_WriteData(uint8_t data) {
  HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);   // Data mode
  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET); // Select LCD

  // 直接发送字节数据，不用指针
  uint8_t tx_data = data;
  while (HAL_SPI_GetState(&hspi2) != HAL_SPI_STATE_READY)
    ;
  HAL_SPI_Transmit(&hspi2, &tx_data, 1, 1000); // 减少超时时间

  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET); // Deselect LCD
}

void LCD_Init(void) {
  // LCD初始化序列 - 移除printf避免卡死
  HAL_Delay(120);

  // Software reset
  LCD_WriteCommand(0x01);
  HAL_Delay(120);

  // Sleep out
  LCD_WriteCommand(0x11);
  HAL_Delay(120);

  // Memory data access control
  LCD_WriteCommand(0x36);
  LCD_WriteData(0x00); // Back to normal orientation

  // Interface pixel format
  LCD_WriteCommand(0x3A);
  LCD_WriteData(0x05); // Back to original: 16-bit RGB565

  // Porch setting
  LCD_WriteCommand(0xB2);
  LCD_WriteData(0x0C);
  LCD_WriteData(0x0C);
  LCD_WriteData(0x00);
  LCD_WriteData(0x33);
  LCD_WriteData(0x33);

  // Gate control
  LCD_WriteCommand(0xB7);
  LCD_WriteData(0x35);

  // VCOM setting
  LCD_WriteCommand(0xBB);
  LCD_WriteData(0x19);

  // LCM control
  LCD_WriteCommand(0xC0);
  LCD_WriteData(0x2C);

  // VDV and VRH command enable
  LCD_WriteCommand(0xC2);
  LCD_WriteData(0x01);

  // VRH set
  LCD_WriteCommand(0xC3);
  LCD_WriteData(0x12);

  // VDV set
  LCD_WriteCommand(0xC4);
  LCD_WriteData(0x20);

  // Frame rate control
  LCD_WriteCommand(0xC6);
  LCD_WriteData(0x0F);

  // Power control 1
  LCD_WriteCommand(0xD0);
  LCD_WriteData(0xA4);
  LCD_WriteData(0xA1);

  // Positive voltage gamma
  LCD_WriteCommand(0xE0);
  LCD_WriteData(0xD0);
  LCD_WriteData(0x04);
  LCD_WriteData(0x0D);
  LCD_WriteData(0x11);
  LCD_WriteData(0x13);
  LCD_WriteData(0x2B);
  LCD_WriteData(0x3F);
  LCD_WriteData(0x54);
  LCD_WriteData(0x4C);
  LCD_WriteData(0x18);
  LCD_WriteData(0x0D);
  LCD_WriteData(0x0B);
  LCD_WriteData(0x1F);
  LCD_WriteData(0x23);

  // Negative voltage gamma
  LCD_WriteCommand(0xE1);
  LCD_WriteData(0xD0);
  LCD_WriteData(0x04);
  LCD_WriteData(0x0C);
  LCD_WriteData(0x11);
  LCD_WriteData(0x13);
  LCD_WriteData(0x2C);
  LCD_WriteData(0x3F);
  LCD_WriteData(0x44);
  LCD_WriteData(0x51);
  LCD_WriteData(0x2F);
  LCD_WriteData(0x1F);
  LCD_WriteData(0x1F);
  LCD_WriteData(0x20);
  LCD_WriteData(0x23);

  // Display inversion on
  LCD_WriteCommand(0x21);

  // Display on
  LCD_WriteCommand(0x29);
  HAL_Delay(100);
}

void LCD_SetAddrWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
  // Column address set
  LCD_WriteCommand(0x2A);
  LCD_WriteData(x0 >> 8);
  LCD_WriteData(x0 & 0xFF);
  LCD_WriteData(x1 >> 8);
  LCD_WriteData(x1 & 0xFF);

  // Page address set
  LCD_WriteCommand(0x2B);
  LCD_WriteData(y0 >> 8);
  LCD_WriteData(y0 & 0xFF);
  LCD_WriteData(y1 >> 8);
  LCD_WriteData(y1 & 0xFF);

  // Memory write
  LCD_WriteCommand(0x2C);
}

void LCD_Clear(uint16_t color) {
  LCD_SetAddrWindow(0, 0, 239, 239);

  HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);   // Data mode
  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET); // Select LCD

  // 临时回退到超大批量阻塞传输（避免DMA问题）
  static uint8_t mega_buffer[9600]; // 4800个像素，20行数据

  // 填充缓冲区
  for (int i = 0; i < 4800; i++) {
    mega_buffer[i * 2] = color >> 8;
    mega_buffer[i * 2 + 1] = color & 0xFF;
  }

  // 使用DMA分12次发送，每次发送20行（4800个像素）
  extern volatile uint8_t dma_transfer_complete;

  for (int batch = 0; batch < 12; batch++) {
    dma_transfer_complete = 0; // 标记传输开始

    if (HAL_SPI_Transmit_DMA(&hspi2, mega_buffer, 9600) == HAL_OK) {
      // 等待DMA传输完成
      while (dma_transfer_complete == 0) {
        // 可以在这里添加超时检测
      }
    } else {
      // DMA失败，回退到阻塞传输
      HAL_SPI_Transmit(&hspi2, mega_buffer, 9600, HAL_MAX_DELAY);
    }
  }

  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET); // Deselect LCD
}

void LCD_FillRect(uint16_t x, uint16_t y, uint16_t w, uint16_t h,
                  uint16_t color) {
  LCD_SetAddrWindow(x, y, x + w - 1, y + h - 1);

  HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);   // Data mode
  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET); // Select LCD

  int total_pixels = w * h;

  // 超大批量阻塞传输（避免DMA问题）
  if (total_pixels > 200) {
    // 大矩形：使用2000像素缓冲区
    static uint8_t rect_buffer[4000]; // 2000个像素缓冲区

    // 填充缓冲区
    for (int i = 0; i < 2000; i++) {
      rect_buffer[i * 2] = color >> 8;
      rect_buffer[i * 2 + 1] = color & 0xFF;
    }

    int full_batches = total_pixels / 2000;
    int remaining = total_pixels % 2000;

    // 使用DMA发送完整的2000像素批次
    extern volatile uint8_t dma_transfer_complete;

    for (int batch = 0; batch < full_batches; batch++) {
      dma_transfer_complete = 0;

      if (HAL_SPI_Transmit_DMA(&hspi2, rect_buffer, 4000) == HAL_OK) {
        while (dma_transfer_complete == 0) {
          // 等待DMA完成
        }
      } else {
        // DMA失败，回退到阻塞传输
        HAL_SPI_Transmit(&hspi2, rect_buffer, 4000, HAL_MAX_DELAY);
      }
    }

    // 发送剩余像素（如果数据量大也用DMA）
    if (remaining > 0) {
      if (remaining > 100) { // 大于100像素用DMA
        dma_transfer_complete = 0;
        if (HAL_SPI_Transmit_DMA(&hspi2, rect_buffer, remaining * 2) ==
            HAL_OK) {
          while (dma_transfer_complete == 0) {
            // 等待DMA完成
          }
        } else {
          HAL_SPI_Transmit(&hspi2, rect_buffer, remaining * 2, HAL_MAX_DELAY);
        }
      } else {
        // 小数据量用阻塞传输
        HAL_SPI_Transmit(&hspi2, rect_buffer, remaining * 2, HAL_MAX_DELAY);
      }
    }
  } else {
    // 小矩形：直接发送
    uint8_t data[2] = {color >> 8, color & 0xFF};
    for (int i = 0; i < total_pixels; i++) {
      HAL_SPI_Transmit(&hspi2, data, 2, HAL_MAX_DELAY);
    }
  }

  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET); // Deselect LCD
}

// 简单的像素绘制函数
void LCD_DrawPixel(uint16_t x, uint16_t y, uint16_t color) {
  if (x >= 240 || y >= 240)
    return;

  LCD_SetAddrWindow(x, y, x, y);

  uint8_t data[2] = {color >> 8, color & 0xFF};

  HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET);   // Data mode
  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET); // Select LCD

  HAL_SPI_Transmit(&hspi2, data, 2, HAL_MAX_DELAY); // 硬件SPI

  HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET); // Deselect LCD
}

// 兼容老项目的点绘制函数名称
void Gui_DrawPoint(uint16_t x, uint16_t y, uint16_t color) {
  LCD_DrawPixel(x, y, color);
}

// 使用ASCII字体显示数字的函数（替换大丑的数码管风格）
void LCD_DrawNumber(uint16_t x, uint16_t y, uint32_t number, uint16_t color,
                    uint16_t bg_color) {
  char num_str[12]; // 足够存放32位数字
  sprintf(num_str, "%lu", number);
  LCD_DrawString(x, y, num_str, color, bg_color);
}

// 完整的8x16 ASCII字符显示函数（使用老项目的字库）
void LCD_DrawChar(uint16_t x, uint16_t y, char ch, uint16_t color,
                  uint16_t bg_color) {
  // ASCII字库数据（从老项目复制）
  const unsigned char asc16[] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //" "
      0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, //"!"
      0x00, 0x00, 0x6C, 0x6C, 0x24, 0x24, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, //"""
      0x00, 0x24, 0x24, 0x24, 0x24, 0xFE, 0x48, 0x48,
      0x48, 0x48, 0xFC, 0x90, 0x90, 0x90, 0x90, 0x00, //"#"
      0x00, 0x10, 0x3C, 0x54, 0x92, 0x90, 0x50, 0x38,
      0x14, 0x12, 0x12, 0x92, 0x54, 0x78, 0x10, 0x00, //"$"
      0x00, 0x00, 0x22, 0x5C, 0x94, 0xA8, 0x48, 0x10,
      0x10, 0x24, 0x2A, 0x52, 0x54, 0x88, 0x00, 0x00, //"%"
      0x00, 0x00, 0x30, 0x48, 0x48, 0x50, 0x20, 0x6E,
      0x54, 0x94, 0x8C, 0x88, 0x8A, 0x74, 0x00, 0x00, //"&"
      0x00, 0x00, 0x30, 0x30, 0x10, 0x10, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"'"
      0x00, 0x04, 0x08, 0x10, 0x10, 0x20, 0x20, 0x20,
      0x20, 0x20, 0x20, 0x10, 0x10, 0x08, 0x04, 0x00, //"("
      0x00, 0x80, 0x40, 0x20, 0x20, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x20, 0x20, 0x40, 0x80, 0x00, //")"
      0x00, 0x00, 0x00, 0x00, 0x10, 0x54, 0x38, 0x10,
      0x38, 0x54, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, //"*"
      0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0xFE,
      0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, //"+"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, //","
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"-"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, //"."
      0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10,
      0x20, 0x20, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, //"/"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x82, 0x82,
      0x82, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"0"
      0x00, 0x00, 0x10, 0x70, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x00, //"1"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x04, 0x08,
      0x10, 0x20, 0x40, 0x82, 0x84, 0xFC, 0x00, 0x00, //"2"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x02, 0x04, 0x38,
      0x04, 0x02, 0x02, 0x82, 0x44, 0x38, 0x00, 0x00, //"3"
      0x00, 0x00, 0x04, 0x0C, 0x14, 0x14, 0x24, 0x24,
      0x44, 0x44, 0xFE, 0x04, 0x04, 0x0E, 0x00, 0x00, //"4"
      0x00, 0x00, 0xFC, 0x80, 0x80, 0x80, 0xB8, 0xC4,
      0x82, 0x02, 0x02, 0x82, 0x84, 0x78, 0x00, 0x00, //"5"
      0x00, 0x00, 0x3C, 0x42, 0x82, 0x80, 0xB8, 0xC4,
      0x82, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"6"
      0x00, 0x00, 0x7E, 0x42, 0x82, 0x04, 0x04, 0x08,
      0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, //"7"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x44, 0x38,
      0x44, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"8"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x82, 0x82,
      0x46, 0x3A, 0x02, 0x82, 0x44, 0x38, 0x00, 0x00, //"9"
      0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,
      0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, //":"
      0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, //";"
      0x00, 0x00, 0x00, 0x00, 0x06, 0x18, 0x60, 0x80,
      0x60, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, //"<"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00,
      0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"="
      0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0x0C, 0x02,
      0x0C, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, //">"
      0x00, 0x38, 0x44, 0x82, 0x82, 0x02, 0x04, 0x08,
      0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, //"?"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x9A, 0xAA, 0xAA,
      0xAA, 0xAA, 0xAA, 0x96, 0x80, 0x42, 0x3C, 0x00, //"@"
      0x00, 0x00, 0x10, 0x10, 0x10, 0x28, 0x28, 0x28,
      0x44, 0x44, 0x7C, 0x44, 0x44, 0xEE, 0x00, 0x00, //"A"
      0x00, 0x00, 0xFC, 0x42, 0x42, 0x42, 0x42, 0x7C,
      0x42, 0x42, 0x42, 0x42, 0x42, 0xFC, 0x00, 0x00, //"B"
      0x00, 0x00, 0x3C, 0x44, 0x82, 0x80, 0x80, 0x80,
      0x80, 0x80, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"C"
      0x00, 0x00, 0xF8, 0x44, 0x42, 0x42, 0x42, 0x42,
      0x42, 0x42, 0x42, 0x42, 0x44, 0xF8, 0x00, 0x00, //"D"
      0x00, 0x00, 0xFC, 0x44, 0x42, 0x40, 0x44, 0x7C,
      0x44, 0x40, 0x40, 0x42, 0x44, 0xFC, 0x00, 0x00, //"E"
      0x00, 0x00, 0xFC, 0x44, 0x42, 0x40, 0x44, 0x7C,
      0x44, 0x40, 0x40, 0x40, 0x40, 0xF0, 0x00, 0x00, //"F"
      0x00, 0x00, 0x34, 0x4C, 0x82, 0x80, 0x80, 0x80,
      0x8E, 0x84, 0x84, 0x84, 0x4C, 0x34, 0x00, 0x00, //"G"
      0x00, 0x00, 0xEE, 0x44, 0x44, 0x44, 0x44, 0x7C,
      0x44, 0x44, 0x44, 0x44, 0x44, 0xEE, 0x00, 0x00, //"H"
      0x00, 0x00, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x00, 0x00, //"I"
      0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08,
      0x08, 0x08, 0x08, 0x88, 0x88, 0x70, 0x00, 0x00, //"J"
      0x00, 0x00, 0xEE, 0x44, 0x48, 0x48, 0x50, 0x60,
      0x50, 0x48, 0x48, 0x44, 0x44, 0xEE, 0x00, 0x00, //"K"
      0x00, 0x00, 0xE0, 0x40, 0x40, 0x40, 0x40, 0x40,
      0x40, 0x40, 0x40, 0x42, 0x44, 0xFC, 0x00, 0x00, //"L"
      0x00, 0x00, 0xC6, 0x44, 0x6C, 0x6C, 0x6C, 0x54,
      0x54, 0x54, 0x44, 0x44, 0x44, 0xEE, 0x00, 0x00, //"M"
      0x00, 0x00, 0xCE, 0x44, 0x64, 0x64, 0x64, 0x54,
      0x54, 0x4C, 0x4C, 0x4C, 0x44, 0xE4, 0x00, 0x00, //"N"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x82, 0x82,
      0x82, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"O"
      0x00, 0x00, 0xF8, 0x44, 0x42, 0x42, 0x42, 0x44,
      0x78, 0x40, 0x40, 0x40, 0x40, 0xE0, 0x00, 0x00, //"P"
      0x00, 0x00, 0x38, 0x44, 0x82, 0x82, 0x82, 0x82,
      0x82, 0x82, 0x82, 0xBA, 0x44, 0x3C, 0x02, 0x00, //"Q"
      0x00, 0x00, 0xF0, 0x48, 0x44, 0x44, 0x44, 0x48,
      0x70, 0x48, 0x44, 0x44, 0x44, 0xE6, 0x00, 0x00, //"R"
      0x00, 0x00, 0x3C, 0x44, 0x82, 0x80, 0x40, 0x30,
      0x0C, 0x02, 0x02, 0x82, 0x44, 0x78, 0x00, 0x00, //"S"
      0x00, 0x00, 0x7C, 0x54, 0x92, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, //"T"
      0x00, 0x00, 0xEE, 0x44, 0x44, 0x44, 0x44, 0x44,
      0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, //"U"
      0x00, 0x00, 0xEE, 0x44, 0x44, 0x44, 0x44, 0x28,
      0x28, 0x28, 0x28, 0x10, 0x10, 0x10, 0x00, 0x00, //"V"
      0x00, 0x00, 0xEE, 0x44, 0x54, 0x54, 0x54, 0x54,
      0x54, 0x54, 0x28, 0x28, 0x28, 0x28, 0x00, 0x00, //"W"
      0x00, 0x00, 0xEE, 0x44, 0x44, 0x28, 0x28, 0x10,
      0x10, 0x28, 0x28, 0x44, 0x44, 0xEE, 0x00, 0x00, //"X"
      0x00, 0x00, 0xEE, 0x44, 0x44, 0x28, 0x28, 0x28,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, //"Y"
      0x00, 0x00, 0x7E, 0x44, 0x84, 0x08, 0x08, 0x10,
      0x20, 0x20, 0x40, 0x82, 0x84, 0xFC, 0x00, 0x00, //"Z"
      0x00, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x00, //"["
      0x00, 0x00, 0x80, 0x80, 0x40, 0x40, 0x20, 0x20,
      0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00, //"\"
      0x00, 0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x00, //"]"
      0x00, 0x30, 0x48, 0x84, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"^"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, //"_"
      0x00, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"`"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x84,
      0x04, 0x7C, 0x84, 0x84, 0x8C, 0x76, 0x00, 0x00, //"a"
      0x00, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x58, 0x64,
      0x42, 0x42, 0x42, 0x42, 0x64, 0x58, 0x00, 0x00, //"b"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44,
      0x80, 0x80, 0x80, 0x80, 0x44, 0x38, 0x00, 0x00, //"c"
      0x00, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x34, 0x4C,
      0x84, 0x84, 0x84, 0x84, 0x4C, 0x36, 0x00, 0x00, //"d"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x84,
      0x84, 0xFC, 0x80, 0x80, 0x84, 0x78, 0x00, 0x00, //"e"
      0x00, 0x00, 0x18, 0x24, 0x20, 0x20, 0xF8, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00, 0x00, //"f"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x44,
      0x44, 0x78, 0x80, 0x7C, 0x82, 0x82, 0x7C, 0x00, //"g"
      0x00, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x58, 0x64,
      0x44, 0x44, 0x44, 0x44, 0x44, 0xEE, 0x00, 0x00, //"h"
      0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x30, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, //"i"
      0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x30, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00, //"j"
      0x00, 0x00, 0xC0, 0x40, 0x40, 0x40, 0x5C, 0x48,
      0x50, 0x60, 0x50, 0x48, 0x44, 0xEE, 0x00, 0x00, //"k"
      0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x11,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x39, 0x00, 0x00, //"l"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xD2,
      0x92, 0x92, 0x92, 0x92, 0x92, 0xD6, 0x00, 0x00, //"m"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0xE4,
      0x44, 0x44, 0x44, 0x44, 0x44, 0xEE, 0x00, 0x00, //"n"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x44,
      0x82, 0x82, 0x82, 0x82, 0x44, 0x38, 0x00, 0x00, //"o"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x64,
      0x42, 0x42, 0x42, 0x64, 0x58, 0x40, 0xE0, 0x00, //"p"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x4C,
      0x84, 0x84, 0x84, 0x4C, 0x34, 0x04, 0x0E, 0x00, //"q"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x30,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x70, 0x00, 0x00, //"r"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x88,
      0x84, 0x60, 0x18, 0x84, 0x44, 0x78, 0x00, 0x00, //"s"
      0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0xF8, 0x20,
      0x20, 0x20, 0x20, 0x20, 0x24, 0x18, 0x00, 0x00, //"t"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x42,
      0x42, 0x42, 0x42, 0x42, 0x46, 0x3A, 0x00, 0x00, //"u"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x44,
      0x44, 0x28, 0x28, 0x28, 0x10, 0x10, 0x00, 0x00, //"v"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x44,
      0x44, 0x54, 0x54, 0x28, 0x28, 0x28, 0x00, 0x00, //"w"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x44,
      0x28, 0x10, 0x10, 0x28, 0x44, 0xEE, 0x00, 0x00, //"x"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x44,
      0x44, 0x28, 0x28, 0x10, 0x10, 0xA0, 0xC0, 0x00, //"y"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x44,
      0x88, 0x10, 0x20, 0x42, 0x84, 0xFC, 0x00, 0x00, //"z"
      0x00, 0x0C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00, //"{"
      0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
      0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, //"|"
      0x00, 0xC0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x18,
      0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xC0, 0x00, //"}"
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72,
      0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"~"
  };

  unsigned char k;
  unsigned char i, j;

  // 处理ASCII字符
  if (ch < 128) {
    k = ch;
    if (k > 32)
      k -= 32;
    else
      k = 0; // 调整索引

    // 绘制字符
    for (i = 0; i < 16; i++) {
      for (j = 0; j < 8; j++) {
        if (asc16[k * 16 + i] & (0x80 >> j)) {
          Gui_DrawPoint(x + j, y + i, color);
        } else {
          if (color != bg_color)
            Gui_DrawPoint(x + j, y + i, bg_color);
        }
      }
    }
  }
}
// 字符串显示函数
void LCD_DrawString(uint16_t x, uint16_t y, const char *str, uint16_t color,
                    uint16_t bg_color) {
  uint16_t pos_x = x;
  while (*str) {
    LCD_DrawChar(pos_x, y, *str, color, bg_color);
    pos_x += 8; // 每个字符宽度8像素
    str++;
  }
}

// 测试LCD显示功能的函数
void LCD_TestFont(uint32_t current_time) {
  // 测试LCD显示功能
  // 简单的LCD活动测试 - 每秒更新一次显示
  static uint32_t last_display_time = 0;
  static uint32_t counter = 0;
  static uint8_t page = 0; // 分页显示页码

  if (current_time - last_display_time >= 3000) { // 每3秒切换一页
    // 清屏
    LCD_Clear(0x0010); // 深蓝色背景

    // 显示页码标题
    switch (page % 4) { // 改回4页循环
    case 0:             // 第1页：系统状态 + 大写字母
      LCD_DrawString(10, 5, "Page 1: System + Upper", 0xFFFF,
                     0x0010); // 白色标题

      // 显示系统状态信息
      LCD_DrawString(10, 25, "SYSTEM INIT: OK", 0x07E0, 0x0010); // 绿色
      LCD_DrawString(10, 45, "LCD INIT: OK", 0x07E0, 0x0010);    // 绿色
      LCD_DrawString(10, 65, "USB INIT: OK", 0x07E0, 0x0010);    // 绿色

      // 显示计数器和时间
      LCD_DrawString(10, 85, "COUNT:", 0xFFE0, 0x0010); // 黄色
      LCD_DrawNumber(70, 85, counter, 0xFFFF,
                     0x0010); // 白色数字 - 使用ASCII字体
      LCD_DrawString(10, 85, "TIME:", 0xFFE0, 0x0010); // 黄色
      LCD_DrawNumber(170, 85, current_time / 1000, 0xFFFF,
                     0x0010); // 白色数字 - 使用ASCII字体

      // 显示USB连接状态
      LCD_DrawString(10, 105, "USB: READY", 0x07E0, 0x0010); // 绿色

      // 显示大写字母 A-Z (26个字母)
      LCD_DrawString(10, 130, "UPPERCASE LETTERS:", 0xFFE0, 0x0010); // 黄色
      for (int i = 0; i < 26; i++) {
        char letter = 'A' + i;
        int x = 10 + (i % 13) * 16;  // 每行13个字符，16像素间距
        int y = 150 + (i / 13) * 20; // 每行高度20像素
        LCD_DrawChar(x, y, letter, 0xFFFF, 0x0010); // 白色字母
      }
      break;

    case 1: // 第2页：小写字母
      LCD_DrawString(10, 5, "Page 2: Lowercase", 0xFFFF, 0x0010); // 白色标题

      // 显示小写字母 a-z (26个字母)
      LCD_DrawString(10, 30, "LOWERCASE LETTERS:", 0xFFE0, 0x0010); // 黄色
      for (int i = 0; i < 26; i++) {
        char letter = 'a' + i;
        int x = 10 + (i % 13) * 16;                 // 每行13个字符
        int y = 50 + (i / 13) * 20;                 // 两行显示
        LCD_DrawChar(x, y, letter, 0x07E0, 0x0010); // 绿色字母
      }

      // 显示数字 0-9
      LCD_DrawString(10, 100, "NUMBERS:", 0xFFE0, 0x0010); // 黄色
      for (int i = 0; i < 10; i++) {
        char digit = '0' + i;
        int x = 10 + i * 20; // 10个数字，20像素间距
        int y = 120;
        LCD_DrawChar(x, y, digit, 0xF81F, 0x0010); // 紫色数字
      }

      // 添加一些系统信息
      LCD_DrawString(10, 150, "Font Test Active", 0x07FF, 0x0010); // 青色
      LCD_DrawString(10, 170, "8x16 ASCII Font", 0x07FF, 0x0010);  // 青色
      LCD_DrawString(10, 190, "Counter:", 0xFFE0, 0x0010);         // 黄色
      LCD_DrawNumber(80, 190, counter, 0xFFFF, 0x0010); // 白色 - 使用ASCII字体
      break;

    case 2: // 第3页：标点符号和特殊字符 (第一部分)
      LCD_DrawString(10, 5, "Page 3: Symbols 1", 0xFFFF, 0x0010); // 白色标题

      // 基本标点符号
      LCD_DrawString(10, 30, "PUNCTUATION:", 0xFFE0, 0x0010); // 黄色
      char punct1[] = "!\"#$%&'()*+,-./:;<=>?@";
      for (int i = 0; punct1[i] != '\0'; i++) {
        int x = 10 + (i % 14) * 16; // 每行14个字符
        int y = 50 + (i / 14) * 20;
        LCD_DrawChar(x, y, punct1[i], 0xF800, 0x0010); // 红色符号
      }

      // 括号和其他符号
      LCD_DrawString(10, 110, "BRACKETS & MORE:", 0xFFE0, 0x0010); // 黄色
      char punct2[] = "[\\]^_`{|}~";
      for (int i = 0; punct2[i] != '\0'; i++) {
        int x = 10 + i * 20;
        int y = 130;
        LCD_DrawChar(x, y, punct2[i], 0xF800, 0x0010); // 红色符号
      }

      // 测试信息
      LCD_DrawString(10, 160, "Special Chars Test", 0x07FF, 0x0010); // 青色
      LCD_DrawString(10, 180, "All ASCII Visible", 0x07FF, 0x0010);  // 青色
      LCD_DrawString(10, 200, "Page 3 of 4", 0xFFE0, 0x0010);        // 黄色
      break;

    case 3: // 第4页：综合测试
      LCD_DrawString(10, 5, "Page 4: Mixed Test", 0xFFFF, 0x0010); // 白色标题

      // 混合文本测试
      LCD_DrawString(10, 30, "Mixed: ABC123!@#", 0xFFFF, 0x0010);  // 白色
      LCD_DrawString(10, 50, "Test: abc456$%^", 0x07E0, 0x0010);   // 绿色
      LCD_DrawString(10, 70, "Symbols: ()[]{}\"", 0xF800, 0x0010); // 红色

      // 完整测试句子
      LCD_DrawString(10, 100, "The Quick BROWN", 0xFFE0, 0x0010); // 黄色
      LCD_DrawString(10, 120, "fox jumps OVER", 0xF81F, 0x0010);  // 紫色
      LCD_DrawString(10, 140, "the lazy DOG!", 0x07FF, 0x0010);   // 青色

      // 数字序列测试
      LCD_DrawString(10, 170, "Numbers: 0123456789", 0xFFFF, 0x0010); // 白色

      // 状态信息
      LCD_DrawString(10, 200, "All Tests Complete!", 0x07E0, 0x0010); // 绿色
      LCD_DrawString(10, 220, "ASCII Font OK!", 0x07E0, 0x0010);      // 绿色
      break;
    }

    // 绘制页面指示器（4个点）
    for (int i = 0; i < 4; i++) {
      uint16_t color =
          (i == (page % 4)) ? 0xFFFF : 0x8410; // 当前页白色，其他页灰色
      LCD_FillRect(200 + i * 8, 5, 6, 6, color); // 恢复4个点的布局
    }

    // 绘制一些动态点作为活动指示器 (commented out for production)
    // LCD_DrawPixel(220 + (counter % 15), 230, 0xFFFF);
    // LCD_DrawPixel(220, 230 - (counter % 15), 0xF800);

    counter++;
    page++; // 切换到下一页
    last_display_time = current_time;
  }
}

/* USER CODE END 4 */
